중부권,8714Y961,37.3388204, 126.7181615
중부권,7629B341,37.629129, 126.4532631
중부권,3312Z911,37.3082256, 127.7568066
중부권,2920W591,37.4602486, 127.659511
중부권,0837C301,37.7686078, 127.1730899
중부권,0000A000,37.1064943, 126.9898329
중부권,3333A000,37.698274,  127.7365727
중부권,3011D201,37.2986809, 127.6733011
중부권,3112Y511,37.3075932, 127.7033385
중부권,9041C091,37.8453131, 126.7625628

강원권,0000A000,37.0989009, 128.9937373
강원권,6666A000,38.2934758, 128.2122102
강원권,0000A999,37.1100923, 128.9954731
강원권,9735C132,37.7563022, 128.8990843
강원권,8354H818,38.0784833, 128.616075

호남(상),6875F971, 36.6561492, 126.2974475
호남(상),0000A000: 35.3041084, 126.9901101
호남(상),9999A000, 37.0884511, 126.9672545
호남(상),9999A000: 37.0885532, 126.9676973

호남(하),9999A000,35.2862005, 126.9681528
호남(하),8800A000,33.5071585, 126.7508456
호남(하),9500A000,33.501309, 126.882842
호남(하),7560A999,34.5859699, 126.4503164

영남(상),0009A000,37.2688532, 128.9890286
영남(상),1111A000,37.2775154, 129.247268
영남(상),6666A000,36.4911492,128.2307546
영남(상),9999A000,37.0888458, 128.9678937

영남(하),0000A000,35.3040563, 128.9898082
영남(하),1111A000,35.5021032, 129.2322314
영남(하),1299A001,35.2861064, 129.2539206
영남(하),6849B721,36.1863353, 128.2876385
영남(하),9999A000,35.2854937, 128.9687563

울릉권,9251X051,37.4784218, 130.8933145
울릉권,9221P142,37.4784218, 130.8933145

제주권,8011P999,33.2430123, 126.566188
제주권,6213B751,33.2845833,126.1837017!16
제주권,7826R501,33.504744, 126.519592
제주권,9622B051,33.449454, 126.9097603


국토지리정보원 지형도에서 사용중인 좌표계입니다.
*서부원점(GRS80)
-falseY:60000
EPSG:5185+proj=tmerc +lat_0=38 +lon_0=125 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs*중부원점(GRS80)
-falseY:60000
EPSG:5186+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs*동부원점(GRS80)
-falseY:60000
EPSG:5187+proj=tmerc +lat_0=38 +lon_0=129 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs*동해(울릉)원점(GRS80)
-falseY:60000
EPSG:5188+proj=tmerc +lat_0=38 +lon_0=131 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs


[NNNN][L][XY][d]
 └──┘ └ └┘ └─┘
  2km  500m 50m  보정
 (숫자4) (알파벳1) (숫자2) (숫자1)
NNNN (숫자 4): 2 km × 2 km 대격자 인덱스(전국 100×100=10,000칸; X 2자리 + Y 2자리)

L (알파벳 1): 같은 2 km 블록을 500 m × 500 m, 4×4=16칸으로 나눈 소관리구 문자

XY (숫자 2): 해당 500 m 블록을 50 m × 50 m, 10×10=100칸으로 나눈 세부격자 (X=09, Y=09)

d (숫자 1): 보정/세분화 용도(09). 실제 좌표로 환산할 때 항상 중심으로 해석(= 09 값과 무관하게 중앙)

예시: 5690W645

5690=2km, W=500m, 64=50m(X=6,Y=4), 5=보정(실제 계산은 중앙)

2) 500 m 알파벳 16개 매핑(2 km 내부 4×4)
규칙도 기준, 북→남 / 서→동 순으로 다음처럼 고정 매핑을 사용합니다.

css
복사
편집
A  B  E  F
C  D  G  H
P  Q  W  X
R  S  Y  Z
행(row): 북쪽이 0행, 남쪽이 3행

열(col): 서쪽이 0열, 동쪽이 3열

주의: A~P 연속이 아니고, 지정된 16문자만 사용

3) 부호화(위치 → 코드) 계산 절차
(1) 좌표 준비
입력: (경도 lon, 위도 lat) 혹은 TM(E,N)

변환: WGS84라면 proj4로 해당 구역의 EPSG(5185/86/87/88)로 변환 → (E, N)

(2) 2 km 인덱스 (NNNN)
원점(앵커) 정하기

방법 A(권장): 보정점(코드↔좌표) 1개로 원점 평행이동값 산출

보정점 코드에서 2km 인덱스(XX,YY)를 읽고
E0 = E_anchor - 2000*XX, N0 = N_anchor - 2000*YY

방법 B(없으면 임시): 해당 EPSG의 false origin을 임시 원점으로 두고 추후 보정

인덱스:

ini
복사
편집
ix2 = floor((E - E0) / 2000)   // X(서→동)
iy2 = floor((N - N0) / 2000)   // Y(남→북)
NNNN = pad2(ix2) + pad2(iy2)   // 각 2자리 00~99
2 km 내부 오프셋:

ini
복사
편집
dE2 = E - (E0 + 2000*ix2)   // 0~<2000
dN2 = N - (N0 + 2000*iy2)   // 0~<2000
(3) 500 m 블록 문자 (L)
2 km 내부 500 m 그리드:

cpp
복사
편집
col4_south = floor(dE2 / 500)    // 0~3 (서→동)
row4_south = floor(dN2 / 500)    // 0~3 (남→북)
// 매핑 표는 "북→남" 기준이므로, 북행 인덱스(rowTop)로 변환
rowTop = 3 - row4_south
L = MAP[rowTop][col4_south]      // 위 표에서 문자 취득
500 m 내부 오프셋:

ini
복사
편집
dE5 = dE2 - 500*col4_south
dN5 = dN2 - 500*row4_south       // 0~<500
(4) 50 m 세부격자 (XY) + 보정(d)
50 m 인덱스:

ini
복사
편집
x50 = floor(dE5 / 50)            // 0~9 (서→동)
y50_south = floor(dN5 / 50)      // 0~9 (남→북)
XY = (x50)(y50_south)            // 예: x50=6, y50=4 → "64"
보정 자리 d는 기록만 하고, 좌표 환산 시 항상 중앙으로 해석합니다.

중앙 해석값: 0.5 셀(= 25 m) 오프셋을 가산하면 됨.

즉, d 값이 0~9 중 무엇이든, 실제 좌표 계산은 동일.

(5) 최종 코드 결합
python
복사
편집
code = pad2(ix2) + pad2(iy2) + L + (x50 as 1 digit) + (y50_south as 1 digit) + d
// 예: "5690" + "W" + "6" + "4" + "5" → "5690W645"
✔ 경계 규칙(권장)
좌/하 경계 포함(inclusive), 우/상 경계 제외(exclusive)

예: 정확히 500 m 선 위의 점은 오른쪽/윗칸으로 넘어가지 않도록 일관 처리

4) 복호화(코드 → 중심 좌표) 절차
입력: NNNN L XY d

2 km 시작점:

ini
복사
편집
XX = int(NNNN[0:2])   // X 방향 2km 인덱스
YY = int(NNNN[2:4])   // Y 방향 2km 인덱스
E2 = E0 + 2000*XX
N2 = N0 + 2000*YY
500 m 블록 오프셋:

java
복사
편집
(rowTop, col4_south) = inverseMap(L)    // 위 16문자 표의 역매핑
row4_south = 3 - rowTop
E5 = E2 + 500*col4_south
N5 = N2 + 500*row4_south
50 m 칸 중심(보정 d는 무시하고 중앙 가정):

ini
복사
편집
x50 = int(XY[0])   // 0~9
y50 = int(XY[1])   // 0~9 (남→북)
E_center = E5 + (x50 + 0.5)*50   // +25 m
N_center = N5 + (y50 + 0.5)*50   // +25 m
필요 시 TM → WGS84로 역변환(proj4 inverse)

5) 보정(캘리브레이션) 전략
1점 보정(Translation): 가장 간단하고 현장용으로 충분한 경우가 많음

알려진 code_anchor ↔ (E_anchor,N_anchor)로부터 E0,N0 산출(위 §3-2)

2~3점 보정(Affine): 넓은 구역·타 타일 소스 혼합 등으로 미세 회전/스케일 오차가 있으면 적용

(E,N) → (E’,N’) = A·(E,N) + b 형태로 6계수 추정 후 위 절차에 대입

6) 구현 체크리스트
 EPSG 선택(5185/86/87/88) 및 proj4 변환

 E0,N0(원점) 보정값 저장(앵커 기반)

 2 km 인덱스/오프셋 계산, 500 m 문자 매핑 표 고정 구현

 50 m 인덱스(XY) 계산, d는 저장만(좌표 환산은 중앙)

 경계 정책 일관 처리(floor/eps)

 클릭 시 코드 생성 / 코드 입력 시 중심점 좌표 반환

 지도(Leaflet/OpenLayers/네이버/카카오) 벡터 그리드 오버레이 표시 옵션

7) 빠른 검증 예시(개념)
가정: 5186, E0=200,000, N0=600,000 (앵커로부터 산출했다고 가정)

점: (E,N)=(201,340, 601,220)

ix2=floor((201,340-200,000)/2,000)=0 → X=00

iy2=floor((601,220-600,000)/2,000)=0 → Y=00 → NNNN=0000

dE2=1,340, dN2=1,220

col4=2, row4_south=2 → rowTop=1 → MAP[1][2]=G → L=G

dE5=1,340-1,000=340 → x50=6

dN5=1,220-1,000=220 → y50=4

d(보정)=임의 5 저장 → 코드 0000G645

복호화 시 중심:

E = 200,000 + 500*2 + (6+0.5)*50 = 201,325

N = 600,000 + 500*2 + (4+0.5)*50 = 601,225

격자 생성해서 
격자안에 숫자 부여시켜서 내가 나중에 백엔드 API로 쓸거야 
지도의 전산화 번호를 
일단 격자먼저 만들어줘
 